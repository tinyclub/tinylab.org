---
layout: post
author: 'lilim'
title: "实时的内核虚拟机 KVM"
# tagline: " 子标题，如果存在的话 "
# album: " 所属文章系列/专辑，如果有的话"
group: "news"
permalink: /Realtime-KVM/
description: "KVM Realtime kernal 虚拟机 实时"
category:
  - Realtime
  - KVM 
tags:
  - KVM Realtime kernal 虚拟机 实时

> By lingjie Li of [TinyLab.org][1]
> Nov 15, 2017

大多数人可能觉得实时虚拟化听起来是矛盾的，但是在一定条件下是成立的,这也证明了Linux内核的灵活性。在[2015 年KVM 论坛][2]的前两位演讲者介绍了如何组建实时内核虚拟机。一位是Rik van Riel他介绍了内核方面所需要做有工作([YouTube在线视频][3]、[演讲PPT][4]),另一位是Jan Kiszka他展示了如何配置宿主机以及如何管理这些实时虚拟机（[YouTube在线视频][5]、[演讲PPT][6)。这篇文章的目的就是重现这两位的演讲，先从Van Riel的演讲开始
## 关于基于优先级的实时内核·PREEMPT_RT kernel

实时性体现与于决策而不是速度，一项需要事实的任务如果在限期内完成不了那会很糟糕。这会导致比如通讯设备出现声音不流畅，在股票交易时错过了最佳时机，抑或是延长汽车或者宇航设备的点火时间。这些应用场景可能在一秒内有上千给期限，允许的最大延迟可能是十几微秒，而且这必须保证在99.999%的情况下都能达到要求，如果不行的话...通常都要求事实。速度虽然很重要，但是为了保证延时在接受范围内，通常会导致吞吐量较低。

几乎所有的延迟都是由系统内核产生的，比如说驱动可以关闭中断并且阻止高优先级的程序执行。自旋锁（Spinlocks）也是导致非实时系统产生延时的一大因素，因为当linux内核在持有一个自旋锁的同时无法调度。通过运行编译是带有PREEMPT_RT(实时内核的补丁集)的内核可以解决这个问题。带有PREEMPT_RT补丁的内核试并不仅是让内核部分模块可抢占，而是力图让内核的所有部分都变成可抢占的。

大部分的改动已经和入了Linus的内核主线,其中包括: 内核任务抢占式支持,优先级继承，高精度的计时器、线程内中断处理，注释了原始的spinlocks ，以及NO_HZ_FULL模式。PREEMPT_RT补丁集一直很大，做的事情相比以前少很多。它主要做的三件事是：将spinlocks换成有优先级的互斥量，将所有中断都放到线程中处理让实时的任务可以抢占，以及[一套可抢占式的读写刷新机制][7]。

最主要的问题是硬件的固件。在X86机器上系统终端管理(SMIs)管理着散热器风扇的转速(包括服务器),操作系统无法阻塞SMIs，在极端的情况下SMIs要几毫秒才能处理结束。除了购买运行状态表现好的设备外没有其他解决方案。hwlatdetct这个内核模块可以帮助检查这个问提，它阻断CPU的中断，找到意外的延迟峰值，并且用model-specific registers(MSRs)找出峰值和SMIs的联系。

## 实时虚拟化，真的吗？

现在，实时虚拟化听起来不太可能，但是这是可以做到的。当然还有些问题：比如，宿主及机无法知道虚拟机(VM)中任务的优先级，而且不知道虚拟机是否持有锁。这限制了调度的灵活性以及阻碍了优先级的继承，因此所有的虚拟CPUs(VCPUs)不的置于非常高的优先级上。只有当[ksoftirqd][8]触发VCPUs的中断，它才有更高的优先级。为了防止宿主机的资源紧张，宿主机要需要划分运行系统任务的CPUs，以及在用于VM的CPUs(被标记了isolcpus以及nohz_full 内核命令参数)。VM需要用相同的方式去对待实时的VCPUs和运行普通任务的VCPUs。宿主机资源紧张会偶尔会导致退回到宿主的用户空间，这可能会占用很长时间就像SMIs在裸金属架构中一样阻碍客户机的调度程序运行。

因此,

为了更好地展示和组织文章，请尽量采用 `_data/categories.yml` 中的分类，如果确实有新增，请在发文前单独提交 PR 更新该文件。

## 内容列表

1. 数字列表，条目 1
  * 普通列表，条目 1
  * 普通列表，条目 2

2. 数字列表，条目 2

## 代码缩进

代码在正文下，用 4 个空格缩进：

    #include <stdio.h>

    int main(void)
    {
       printf('Hello, World!');
    }

*注*: 如果要跟列表一起缩进显示，得添加相应空格。

## 正文内内嵌代码

如果正文中包含了命令、接口、代码片段、变量等属于代码的部分时，请用 ` 括起来，例如：`grep Free /proc/meminfo`，用法为：

    `grep Free /proc/meminfo`

## 中英文以及数字混排

当中 English 文以及中文、数字混排时，记得在 English 和数字，例如 1 2 3 4 周边添加空格，进而确保可阅读性，即 Readability。

## 表格用法

| 标题 1      | 标题 2     | 标题 3          |
|-------------|-----------:|:---------------:|
| 左对齐      |右对齐      | 居中对齐        |

## 在正文中嵌入图片

Markdown 基本语法如下：

![图片名](/images/weibo/tinylaborg.jpg '图片内容提示，可选')

*注*：如果想规范图片大小，想增加额外的特性，可以用 html 的 `<img>` 标记。

## 链接以及各类内容混排

### 链接

* [链接用法一][1]

  在列表后面放入脚本，为了确保跟列表一起缩进，需要额外增加两个空格：

      #!/bin/bash
      echo 'Hello, World.'


* [另外一种链接用法](http://tinylab.org)

  在列表后面再嵌入子列表，包括数字列表和非数字列表：

  * Another list
    * Another list
      1. Third list
      2. Third list


* 第三种链接用法：<http://tinylab.org>

### 更复杂的列表用法

1. 表项 1

    这里再嵌入代码：

        #include <stdio.h>

        int main() { return 0; }

2. 表项 2

    这里嵌入图片：

    ![图片名](/images/weibo/tinylaborg.jpg '图片内容描述信息')

3. 表项 3

    普通正文

4. 表项 4
  * 数字表项嵌入非数字表项，表项 1
  * 表项 2

        | 标题 1      | 标题 2     | 标题 3          |
        |-------------|-----------:|:---------------:|
        | 左对齐      |右对齐      | 居中对齐        |

*注*：数字列表跟普通列表有一个差别是，数字列表后面如果要加正文自动缩进，得增加 4 个空格，而普通列表只需要两个。估计是 Markdown 解释器的问题，请尽量遵循这个约定吧。

## 正文引用

如果要引用第三方的信息，可以这么做：

> 这里是来自第三方的信息，信息内容可以用普通的 Markdown 语法来标记[链接][1]、**加粗**、`命令`等等，很灵活。。。

[1]: http://tinylab.org
[2]: http://events.linuxfoundation.org/events/kvm-forum
[3]: http://www.youtube.com/watch?v=cZ5aTHeDLDE
[4]: http://www.linux-kvm.org/images/2/24/01x02-Rik_van_Riel-KVM_realtime.pdf
[5]: https://www.youtube.com/watch?v=SyhfctYqjc8
[6]: http://www.linux-kvm.org/images/0/0d/01x03-Jan_Kiszska-KVM_RT_for_masses.pdf
[7]: https://lwn.net/Articles/253651/
[8]: https://lwn.net/Articles/520076/
[8]: 

